#!/usr/bin/env python
# -*- encoding: utf-8 -*-
# ______________________________________________________________________
#
#  Copyright © 2013 bjarneh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ______________________________________________________________________
#
#  The program is organized into these sections:
# 
#  0. __doc__ [-help menu]
#  1. global variables
#  2. templates
#  3. program functions
#  4. main
#  5. Pkg [represents a java package]
#  6. Lib [represents a java library]
#  7. utility functions
#  8. Pyopt [command line parser]
#  9. init
#
#  The main function should give you a good idea of the program flow.
#  Each section is devided with a horizontal line of underscores.
# ______________________________________________________________________


"""
 jz - java compilation, testing, zipping etc.

 usage: jz [OPTIONS]

 options:

  -h --help     :  print this menu and exit
  -v --version  :  print version and exit
  -l --list     :  list command line options current value
  -x --strip    :  dirnames to exclude (default: .svn,.hg,.git,.bzr)
  -u --dep      :  print dependency information gathered
  -z --zlib     :  compress zip-files (jar-archives) with zlib
  -f --full     :  compile entire project, not only modified files
  -F --fast     :  compile project as fast as possible (only modified files)
  -c --clean    :  remove class-files, jar-file, and javadoc html
  -t --test     :  run unit-tests using junit (will be downloaded)
  -S --src      :  path to a source root (default: src)
  -O --obj      :  path to produced class-files (default: obj)
  -H --htm      :  path to produced javadoc (default: htm)
  -L --lib      :  path to library dir added to -classpath (default: lib)
  -D --dst      :  path to dir where jar file is placed (default: dst)
  -R --res      :  path to dir which is included in jar-file (default: res)
  -p --pack     :  include dependency libs to produce a stand alone jar
  -w --war      :  put class files under 'WEB-INF/classes' in jar file
  -d --doc      :  produce javadoc for project, with some sane defaults
  -N --nolink   :  do not add '-linksource' argument for javadoc
  -n --name     :  name of jar file containing project (default: a.jar)
  -o --output   :  produce an executable shell-script containing the project
  -m --main     :  name of entry point class for stand alone execution
  -M --manifest :  path to (complete) manifest for the generated jar file
  --classpath   :  locations of user class files and annotation processors
  --javahome    :  location of jdk, or chosen jdk to use to compile src
"""


# ______________________________________________________________ imports

import os         # os independent?
import re         # parse with regexp
import sys        # printing/argv/exit
import imp        # import dynamic modules
import time       # do some basic timing
import atexit     # delete tmp files on exit
#import urllib2   # moved to 'wget' [adds overhead]
import zipfile    # write zip (jar) files
#import cProfile  # run profile tool
import traceback  # print stacktrace
import subprocess # run external commands

# ______________________________________________________________ globals

__version__    = "jz 1.0"
__author__     = "bjarneh@ifi.uio.no"


# ------------------------------------------------------ 
# config can be overridden by command line arguments
# ------------------------------------------------------ 


config = {} # command line + config-file options
config['-src']        = 'src'   # -S
config['-obj']        = 'obj'   # -O
config['-htm']        = 'htm'   # -H
config['-res']        = 'res'   # -R
config['-lib']        = ['lib'] # -L
config['-dst']        = 'dst'   # -D
config['-main']       = None    # -m
config['-manifest']   = None    # -M
config['-output']     = None    # -o
config['-nolink']     = False   # -N
config['-full']       = False   # -f
config['-fast']       = False   # -F
config['-pack']       = False   # -p
config['-doc']        = False   # -d
config['-dep']        = False   # -u
config['-clean']      = False   # -c
config['-test']       = False   # -t
config['-help']       = False   # -h
config['-list']       = False   # -l
config['-zlib']       = False   # -z
config['-dryrun']     = False   #
config['-war']        = False   # -w
config['-quiet']      = False   # -q
config['-version']    = False   # -v
config['-name']       = 'a.jar' # -n
config['-strip']      = '.hg,.git,.svn,.bzr' # -x
config['-javahome']   = os.environ.get('JAVA_HOME')
config['-classpath']  = os.environ.get('CLASSPATH')
config['-link']       = ['http://docs.oracle.com/javase/6/docs/api/']
config['windows']     = sys.platform.startswith('win')
config['xargs']       = []


# use regexp to parse files ☻
pkg_regex   = re.compile(r"""package\s+([\w.\-_\d]+);""")
imprt_regex = re.compile(r"""import\s+([\w.\-_\d]+)\.[^\.;]+;""")
imprt2_regx = re.compile(r"""import\s+static\s+([\w.\-_\d]+)\.[\w.\-_\d]+\.[^\.;]+;""")
###stop_regex  = re.compile(r"""^\s*(final|public|class|interface|enum)\s+.*$""")
# main regex will match (args can be argv as well)
# 1: public static void main(String[] args)
# 2: public static void main(String args[])
# 3: public static void main(String... args)
main_start  = r"""public\s+static\s+void\s+main\s*\(\s*String"""
main_stop   = r"""(\[\]\s+arg(s|v)|\s+arg(v|s)\[\]|\s*\.\.\.\s+arg(s|v))\s*\)"""
main_regex  = re.compile(main_start + main_stop)
# regexp to look for junit library
junit_regex = re.compile(r"""junit[\d\-.]*\.jar""")

# command line parser
pyopt = None

# plugins
plugins = {}

# ______________________________________________________________ templates

# junit template to run the unit tests
junit_template = """// generated
package com.github.bjarneh.jz;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

public class JzTestRunner {

    public static void runThem(String jarfile) {
        String[] tests = findTests(jarfile);
        org.junit.runner.JUnitCore.main(tests);
    }

    private static String[] findTests(String jarfile) {
        ArrayList<String> tests = new ArrayList<String>();
        try {
            JarFile jf = new JarFile(jarfile);
            for (Enumeration<JarEntry> e = jf.entries(); e.hasMoreElements();) {
                String name = e.nextElement().getName();
                if (name.endsWith("Test.class") && !name.contains("$")){
                        tests.add(name.replaceAll(File.separator, ".")
                            .substring(0, name.length() - 6));
                }
            }

            jf.close();

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return tests.toArray(new String[0]);
    }

    public static void main(String[] args) {
        if( args.length > 0 ){
            runThem(args[0]);
        }else{
            System.out.printf(" no filename given\\n");
        }
    }
}
"""

bash_template = """#!/bin/bash

function die() {
    echo "$1"
    exit 1
}

# Taken from Debian Developers Reference Chapter 6
function pathfind() {
     OLDIFS="$IFS"
     IFS=:
     for p in $PATH; do
         if [ -x "$p/$*" ]; then
             IFS="$OLDIFS"
             return 0
         fi
     done
     IFS="$OLDIFS"
     return 1
}

pathfind "java" || die "[ERROR] could not find: java in \$PATH"

exec java -jar $0 "$@"
            


"""

# ______________________________________________________________ program funcs

def init_parser():
    """ initialize option parser """

    # you see Perl; a few 'global' or a million 'my'?
    global pyopt

    pyopt = Pyopt()
    pyopt.add_bool('-h -help --help help')
    pyopt.add_bool('-v -version --version')
    pyopt.add_bool('-c -clean --clean clean')
    pyopt.add_bool('-q -quiet --quiet')
    pyopt.add_bool('-z -zlib --zlib')
    pyopt.add_bool('-dryrun --dryrun')
    pyopt.add_bool('-d -doc --doc doc')
    pyopt.add_bool('-u -dep --dep')
    pyopt.add_bool('-f -full --full')
    pyopt.add_bool('-F -fast --fast')
    pyopt.add_bool('-l -list --list')
    pyopt.add_bool('-w -war --war')
    pyopt.add_bool('-p -pack --pack')
    pyopt.add_bool('-N -nolink --nolink')
    pyopt.add_bool('-t -test --test test')
    pyopt.add_str_fancy('-x --strip')
    pyopt.add_str_fancy('-S --src')
    pyopt.add_str_fancy('-O --obj')
    pyopt.add_str_fancy('-H --htm')
    pyopt.add_str_fancy('-R --res')
    pyopt.add_str_fancy('-L --lib')
    pyopt.add_str_fancy('-D --dst')
    pyopt.add_str_fancy('-M --main')
    pyopt.add_str_fancy('-n --name')
    pyopt.add_str_fancy('-m --manifest')
    pyopt.add_str_fancy('--link')
    pyopt.add_str_fancy('-o --output')
    pyopt.add_str_fancy('--javahome')
    pyopt.add_str_fancy('--classpath')


def plugin_init():
    """ look for plugins and initialize """

    pwd  = os.getcwd()
    xdg  = os.environ.get('XDG_CONFIG_HOME')
    home = os.environ.get('HOME') or os.environ.get('USERPROFILE')

    if not xdg and home:
        xdg = os.path.join(home, '.config')

    plugin_dirs = []
    plugin_files = []

    if pwd:
        p = os.path.join(pwd, '.jz', 'plugins')
        if os.path.isdir( p ):
            plugin_dirs.append( p )
    if home:
        p = os.path.join(home, '.jz', 'plugins')
        if os.path.isdir( p ):
            plugin_dirs.append( p )
    if xdg:
        p = os.path.join(xdg, 'jz', 'plugins')
        if os.path.isdir( p ):
            plugin_dirs.append( p )

    if plugin_dirs:
        for d in plugin_dirs:
            files = path_walk( d, py_module_matcher, config['-strip'] )
            if files:
                plugin_files += files

    if plugin_files:
        plugin_load( plugin_files )


def plugin_load(files):
    """ 
    a python module is considered a plugin if it is
    located one level under a plugins directory, i.e.
    $A_DIR_IN_PLUGIN_PATH/plugins/NAME/__init__.py
    """

    global plugins
    global pyopt
    global config

    for f in files:
        stubs = f.split(os.path.sep)
        if len(stubs) > 3 and stubs[-3] == 'plugins':
            try:
                m = imp.load_source("plugin", f)
                p = m.get_plugin()
                plugins[p.URI] = p
                if 'set_parser' in dir(p):
                    p.set_parser( pyopt )
                if 'set_config' in dir(p):
                    p.set_config( config )
            except Exception, e:
                sys.stderr.write("%s" % e)
                #pass


def plugin_after_parsing():
    """
    we are done parsing command line arguments
    it's time for plugins to inspect results
    """

    global plugins

    for k in plugins:
        if 'after_parsing' in dir(plugins[k]):
            plugins[k].after_parsing(config['xargs'])
 

def plugin_deps(libs):
    """
    notify plugins about our dependencies, both
    the Lib objects, and the -classpath arguments
    """

    global plugins

    for k in plugins:
        if 'set_deps' in dir(plugins[k]):
            plugins[k].set_deps(libs, config['-classpath'])


def plugin_get_matcher( matcher ):
    """ allow plugins to manipulate the files we look for """

    global plugins

    matcher_plugins     = []
    alternative_matcher = matcher

    count = 0

    for k in plugins:
        if 'get_matcher' in dir(plugins[k]):
            m = plugins[k].get_matcher()
            if m:
                alternative_matcher = m
                matcher_plugins.append( plugins[k].URI )
                count += 1
                if count > 1:
                    sys.stderr.write("[ERROR] < 1 plugin has a matcher!\n")
                    for u in matcher_plugins:
                        sys.stderr.write("  * %s\n"% u)
                    sys.exit(1)

    return alternative_matcher


def plugin_get_files( files ):
    """ allow plugins to manipulate the files after they were chosen """

    global plugins

    for k in plugins:
        if 'get_files' in dir(plugins[k]):
            f = plugins[k].get_files(files)
            if f:
                files = f
    return files


def plugin_set_pkgs( pkgs ):
    """ allow plugins to manipulate packages """

    global plugins

    for k in plugins:
        if 'set_pkgs' in dir(plugins[k]):
            plugins[k].set_pkgs( pkgs )


def plugin_build_calculated( pkgs ):
    """ allow plugins to manipulate packages """

    global plugins

    for k in plugins:
        if 'build_calculated' in dir(plugins[k]):
            plugins[k].build_calculated( pkgs )


def parse_args( argv ):
    """ parse command line arguments || config file """
    
    global pyopt
    global plugins

    rest = pyopt.parse( argv )

    if pyopt.is_set('-help')   : config['-help']    = True
    if pyopt.is_set('-test')   : config['-test']  = True
    if pyopt.is_set('-doc')    : config['-doc']     = True
    if pyopt.is_set('-clean')  : config['-clean']   = True
    if pyopt.is_set('-dryrun') : config['-dryrun']  = True
    if pyopt.is_set('-version'): config['-version'] = True
    if pyopt.is_set('-quiet')  : config['-quiet']   = True
    if pyopt.is_set('-zlib')   : config['-zlib']    = True
    if pyopt.is_set('-dep')    : config['-dep']     = True
    if pyopt.is_set('-list')   : config['-list']    = True
    if pyopt.is_set('-full')   : config['-full']    = True
    if pyopt.is_set('-fast')   : config['-fast']    = True
    if pyopt.is_set('-pack')   : config['-pack']    = True
    if pyopt.is_set('-nolink') : config['-nolink']  = True
    # do not allow -war target to be true if we are testing
    if pyopt.is_set('-war')    :
        config['-war'] = not config['-test']

    if pyopt.is_set('-src'): config['-src'] = pyopt.get('-src')
    if pyopt.is_set('-obj'): config['-obj'] = pyopt.get('-obj')
    if pyopt.is_set('-htm'): config['-htm'] = pyopt.get('-htm')
    if pyopt.is_set('-res'): config['-res'] = pyopt.get('-res')
    if pyopt.is_set('-lib'): config['-lib'] += pyopt.get_all('-lib')
    if pyopt.is_set('-dst'): config['-dst'] = pyopt.get('-dst')
    if pyopt.is_set('-main'): config['-main'] = pyopt.get('-main')
    if pyopt.is_set('-name'): config['-name'] = pyopt.get('-name')
    if pyopt.is_set('-link'): config['-link'] = pyopt.get_all('-link')
    if pyopt.is_set('-strip'): config['-strip'] = pyopt.get('-strip')
    if pyopt.is_set('-output'): config['-output'] = pyopt.get('-output')
    if pyopt.is_set('-javahome'): config['-javahome'] = pyopt.get('-javahome')
    if pyopt.is_set('-manifest'): config['-manifest'] = pyopt.get('-manifest')

    # somewhat special, append if not empty CLASSPATH variable on init
    if pyopt.is_set('--classpath'):
        if config['-classpath']:
            config['-classpath'] += os.pathsep + pyopt.get('-classpath')
        else:
            config['-classpath'] = pyopt.get('-classpath')

    if rest: config['xargs'] += rest

    # give results to plugins
    if plugins:
        for k in plugins:
            if 'argv_parsed' in dir(plugins[k]):
                plugins[k].argv_parsed( rest )

    pyopt.reset() # reset all options to False or None

    return rest


def parse_config():
    """ parse possible config files """

    pwd  = os.getcwd()
    xdg  = os.environ.get('XDG_CONFIG_HOME')
    home = os.environ.get('HOME') or os.environ.get('USERPROFILE')

    if not xdg and home:
        xdg = os.path.join(home, '.config')

    cfg_files = []

    if pwd:
        cfg_files.append(os.path.join(pwd, '.jzrc'))
        cfg_files.append(os.path.join(pwd, 'jzrc'))
    if home:
        cfg_files.append(os.path.join(home, '.jzrc'))
        cfg_files.append(os.path.join(home, '.config','jz','config'))
    if xdg:
        cfg_files.append(os.path.join(xdg,'jz','config'))

    if cfg_files:
        for f in cfg_files:
            cfg_argv = config_to_argv(f)
            if cfg_argv:
                parse_args(cfg_argv)


def jdk_sanity(prg='javac'):
    """ look for jdk program: javac, javadoc """

    java_home = None

    if config['-javahome']:
        java_home = config['-javahome']
    
    if java_home:
        prg_path = os.path.join(java_home, 'bin', prg)
        if not os.access(prg_path, os.X_OK):
            die("'%s' not found in JAVA_HOME=%s\n", prg, java_home)
    else:
        prg_path = which(prg)
        if not prg_path:
            die("'%s' not installed\n", prg)

        # set JAVA_HOME based on location of jdk-program
        actual = follow_link( prg_path )
        java_home_bin = os.path.dirname( actual )
        java_home     = os.path.dirname( java_home_bin )
    
    # set JAVA_HOME for later
    config['-javahome']     = java_home
    config[prg]             = os.path.join( java_home, 'bin', prg )
    os.environ['JAVA_HOME'] = java_home


def build_classpath():
    """ create Lib objects and config['-classpath'] values """

    libs = []
    class_path = []

    for d in config['-lib']:
        if os.path.isdir( d ):
            jars = path_walk( d, jar_matcher, config['-strip'] )
            for j in jars:
                libs.append( Lib(j) ) # stuff these into jar for standalone
                class_path.append( j )

    if config['-classpath']:
        class_path.append( config['-classpath'] )

    class_path.append( config['-obj'] )

    config['-classpath'] = os.pathsep.join( class_path )

    return libs


def find_pkgs(files):
    """ use regexp to parse files (hoho) """

    # 'name' -> Pkg('name')
    pkgs   = {}

    for f in files:

        pk  = None
        dep = []
        ent = None # entry point (main function)

        fh  = open(f)

        lns = fh.read()
        fh.close()

        m = pkg_regex.search( lns )
        if m:
            pk = m.group(1)

        im = imprt_regex.findall( lns )
        if im:
            dep += im

        im = imprt2_regx.findall( lns )
        if im:
            dep += im
    
        ent = main_regex.search( lns )

        if not pk:
            pk = '.' # dummy package (illegal Java package name)

        if not pk in pkgs:
            pkgs[pk] = Pkg(pk)

        pkgs[pk].add_file( f )

        for d in dep:
            pkgs[pk].depends_on( d )

        if ent:
            pkgs[pk].add_entry( f )

    return pkgs


def build_dep_graph( pkgs ):
    """
    build the dependency graph, we can 
    safely ignore reverse dependencies
    """
    for k in pkgs:
        for dep in pkgs[k].deps:
            if dep in pkgs:
                pkgs[dep].add_child(pkgs[k])


def find_outdated_pkgs( pkgs ):
    """
    find out whether or not packages are outdated
    """

    # no pkg can be up-to-date if this dir is missing
    if not os.path.isdir(config['-obj']) or config['-full']:
        for k in pkgs:
            pkgs[k].make = True
    else:
        for k in pkgs:
            pkgs[k].stat_compare(config['-obj'])


def javac_outdated_pkgs( pkgs ):
    """ use javac to compile modified packages and their children """

    pkg_mk_count = 0

    javac_cmd = 'javac.exe' if config['windows'] else 'javac'

    cmd = []
    cmd.append(config[javac_cmd])
    cmd.append('-d')
    cmd.append(config['-obj'])
    cmd.append('-sourcepath')
    cmd.append(config['-src'])
    cmd.append('-cp')
    cmd.append(config['-classpath'])
    # assume user knows what he || she is adding
    if config['xargs']: cmd += config['xargs']

    tmp_len = len(cmd)

    for k in pkgs:
        if pkgs[k].make:
            if config['-fast']:
                cmd += pkgs[k].modified(config['-obj'])
            else:
                cmd += pkgs[k].files
            pkg_mk_count += 1

    if pkg_mk_count == 0:
        return False

    if not config['-dryrun']:
        dir_or_mkdir( config['-obj'] )

    if config['-fast']:
        info("compiling: %d files\n", len(cmd) - tmp_len)
    else:
        info("compiling: %d/%d packages\n", pkg_mk_count, len(pkgs))
    run_cmd(cmd, config['-dryrun'], 'compile failed')

    return True


def zip_objs( pkgs, libs, done_stuff ):
    """ zip .class files into config['-dst']/config['-name'] """

    jar_file = os.path.join(config['-dst'], config['-name'])

    # always zip and write new manifest if we pack libs
    if config['-output'] or config['-pack']:
        done_stuff = True

    if os.path.isfile( jar_file ) and not done_stuff:
        jar_mod = os.stat(jar_file).st_mtime
        for k in pkgs:
            t = pkgs[k].latest_class_file(config['-obj'])
            if t > jar_mod:
                zip_objs( pkgs, libs, True )
        return None

    else:

        dir_or_mkdir(config['-dst'])
        manifest_dir = os.path.join(config['-obj'], 'META-INF')
        dir_or_mkdir(manifest_dir)
        write_manifest(manifest_dir, libs)

        manifest_path = os.path.join(manifest_dir, 'MANIFEST.MF')
        manifest_zip_path = os.path.join('META-INF','MANIFEST.MF')

        info("zip it up: %s\n"% jar_file)

        # the zip/jar archive
        if config['-zlib']:
            zip_fh = zipfile.ZipFile(jar_file, 'w', zipfile.ZIP_DEFLATED)
        else:
            zip_fh = zipfile.ZipFile(jar_file, 'w')

        # manifest should be first
        zip_fh.write(manifest_path, manifest_zip_path)

        for f in path_walk(config['-obj'], class_matcher, None):
            out_name = f[len(config['-obj'])+1:]
            if config['-war']: # special case we are building a war file
                out_name = os.path.join('WEB-INF','classes',out_name)
            zip_fh.write(f, out_name)
        zip_fh.close()

        return jar_file


def write_manifest(to_dir, libs):
    """ write default manifest, or user provided """

    mnf = os.path.join(config['-res'], 'META-INF', 'MANIFEST.MF')

    fh  = open(os.path.join(to_dir, 'MANIFEST.MF'), 'w')

    if config['-manifest'] or os.path.isfile( mnf ):
        fh_user_manifest = open(config['-manifest'] or mnf , 'r')
        fh.write(fh_user_manifest.read())
        fh_user_manifest.close()
    else:
        fh.write('Manifest-Version: 1.0\n')
        fh.write('JZ-Version: jz 1.0\n')
        fh.write('Created-By: jz 1.0\n')
        if config['-output'] or config['-pack']:
            if libs:
                fh.write('Class-Path: ')
                # TODO assert we are writing to empty directory
                p = map(lambda x: os.path.join('lib', x.base()), libs)
                fh.write(' '.join(p))
                fh.write('\n')
        if config['-main']:
            fh.write('Main-Class: %s\n'% config['-main'])
        fh.write('\n\n')
    fh.close()


def add_resources():
    """ add everything in config['-res'] to jar """

    if not os.path.isdir(config['-res']): return

    jar_name = os.path.join(config['-dst'],config['-name'])

    if config['-zlib']:
        jar_fh = zipfile.ZipFile(jar_name, 'a', zipfile.ZIP_DEFLATED)
    else:
        jar_fh = zipfile.ZipFile(jar_name, 'a')

    info("add 2 zip: %s\n"% config['-res'])

    for f in path_walk(config['-res'], any_matcher, config['-strip']):
        jar_fh.write(f, f[len(config['-res'])+1:])

    jar_fh.close()


def clean():
    """ remove compiled code + javadoc etc """

    for e in ['-obj', '-htm', '-dst']:
        if os.path.isdir( config[e] ):
            info('rm -rf: %s\n' % config[e])
            rm_rf( config[e] )
            parent = os.path.dirname(config[e])
            if parent:
                rm_empty_dirs(parent)
    sys.exit(0)


def javadoc(files):
    """ run javadoc on src """

    javadoc_cmd = 'javadoc.exe' if config['windows'] else 'javadoc'
    
    dir_or_mkdir(config['-htm'])

    cmd = []
    cmd.append(config[javadoc_cmd])
    if not config['-nolink']:
        cmd.append('-linksource')
    cmd.append('-classpath')
    cmd.append(config['-classpath'])
    cmd.append('-d')
    cmd.append(config['-htm'])
    if config['-quiet']:
        cmd.append('-quiet')
    if config['-link']:
        for lnk in config['-link']:
            cmd.append('-link');
            cmd.append(lnk)
    # assume user knows what he || she is adding
    if config['xargs']: cmd += config['xargs']
    cmd += files

    run_cmd(cmd, config['-dryrun'])
    sys.exit(0)


def write_junit_stub():
    """ write code stub to run tests, see templates """

    test_dir = os.path.join(config['-src'],"com","github","bjarneh","jz")
    dir_or_mkdir(test_dir)

    test_file = os.path.join(test_dir, "JzTestRunner.java")
    atexit.register( rm_junit_template, test_file, None )

    fd = open(test_file, 'w')
    fd.write(junit_template)
    fd.close()


def rm_junit_template(fname, arg=None):
    """ remove the junit template code from 'src' dir """
    d = os.path.dirname(fname)
    os.unlink(fname)
    rm_empty_dirs(d, True)


def junit_sanity():
    """ look for the existence of junit in -classpath """

    paths = config['-classpath'].split(os.pathsep)

    found        = False
    looking_for  = os.sep.join(['org','junit','runner','JUnitCore'])
    looking_for += '.class'

    for p in paths:
        # we should ideally check for version of junit, but well...
        if p.find('junit') != -1 and p.endswith('.jar'):
            zip_fh = zipfile.ZipFile(p, 'r')
            files  = zip_fh.namelist()
            zip_fh.close()
            if looking_for in files:
                found = True
                break

    if not found:
        answ = raw_input(" \n JUnit not found, download it? [Y/n]: ")
        answ = answ.lower()
        if not answ or answ in ['y', 'yes']:
            print(" Downloading.... [v4.10] junit.jar\n")
            dir_or_mkdir( config['-lib'][0] )
            junit_lib = wget("http://bjarneh.at.ifi.uio.no/junit.jar")
            fh = open(os.path.join(config['-lib'][0], 'junit.jar'), 'w')
            fh.write( junit_lib )
            fh.close()
            junit_location = os.path.join(config['-lib'][0], 'junit.jar')
            config['-classpath'] += (os.pathsep + junit_location)
        else:
            die(" Ok, goodbye..\n\n")


def junit():
    """ run junit tests if junit is present in -classpath """

    jar_name = os.path.join(config['-dst'], config['-name'])

    info("\n======= TESTING ======= \n\n")

    cmd = []
    cmd.append('java.exe' if config['windows'] else 'java')
    cmd.append('-classpath')
    cmd.append(config['-classpath'] + os.pathsep + jar_name)
    cmd.append('com.github.bjarneh.jz.JzTestRunner')
    cmd.append(jar_name)

    if config['-dryrun']:
        run_cmd( cmd, True)
    else:
        fail = subprocess.call(cmd)
        if fail:
            die("\n======= FAILED ======= \n\n")
        else:
            info("======= SUCCESS ======= \n\n")
    sys.exit(0)


def add_deps( libs ):
    """ add dependencies to jar file """

    # nothing to do then
    if not libs: return

    jar_name = os.path.join(config['-dst'], config['-name'])

    # don't recompress zip-files perhaps?
    if config['-zlib']:
        jar_fh = zipfile.ZipFile(jar_name, 'a', zipfile.ZIP_DEFLATED)
    else:
        jar_fh = zipfile.ZipFile(jar_name, 'a')

    for lib in libs:
        lib.add_to( jar_fh )

    jar_fh.close()


def assert_main( pkgs ):
    """ make sure we have a main entry point """

    # assume user knows how stuff works
    if config['-main'] or config['-manifest']: return True

    manifest = os.path.join('META-INF', 'MANIFEST.MF')
    jar_name = os.path.join(config['-dst'], config['-name'])
    zip_fh   = zipfile.ZipFile(jar_name, 'r')
    content  = zip_fh.read(manifest)
    zip_fh.close()

    if content.find('Main-Class:') != -1: return False

    # start looking yourself
    entry_points = []

    for k in pkgs:
        if pkgs[k].entry:
            entry_points += pkgs[k].entry

    if not entry_points:
        die("[ERROR] no main function found\n")

    choice  = choose_entry( entry_points )
    lines   = content.split("\n")
    n_lines = []
    for line in lines:
        if line:
            n_lines.append(line)
        else:
            break
    n_lines.append("Main-Class: %s"% entry_points[choice])
    n_lines.append("\n")

    # overwrite old MANIFEST file
    zip_fh = zipfile.ZipFile(jar_name, 'a')
    zip_fh.writestr(manifest, '\n'.join(n_lines))
    zip_fh.close()

    return True


def choose_entry( choices ):
    """ choose an entry point """

    if not choices: die("[ERROR] no entry points\n")
    if len(choices) == 1: return 0

    print("\nYou have not chosen an entry point (Main-Class)\n")
    for i, e in enumerate(choices):
        print(" %2d - %s"%( i, e ))
    entry  = raw_input("\nType your choice >  ")
    print('')
    ientry = int(entry)
    if ientry not in range(0, len(choices)):
        raise Exception(" %d : not in range"% ientry)
    return ientry


def bash_script(work_was_done):
    """
    write bash script stub and executable jar to a file
    """

    jar_name = os.path.join(config['-dst'], config['-name'])

    # do nothing if file exists and is newer than jar-file
    if os.path.isfile(config['-output']) and not work_was_done:
        timestamp_out = os.stat(config['-output']).st_mtime
        timestamp_jar = os.stat(jar_name).st_mtime
        if timestamp_out >= timestamp_jar:
            return

    info("shell/jar: %s\n", config['-output'])
    fh_bash = open(config['-output'], 'w+b')
    fh_bash.write(bash_template)
    fh_jar = open(jar_name, 'r+b')
    fh_bash.write(fh_jar.read())
    fh_jar.close()
    fh_bash.close()
    os.chmod(config['-output'], 0755)


def info(fmt, *args):
    """ print an info message if !quiet """
    if not (config['-quiet'] or config['-dryrun']):
        out_str = fmt%(args) if args else "%s"%(fmt)
        sys.stdout.write(out_str)


def echo_exit(something, status=0):
    """ echo something and exit with status """
    if status != 0:
        sys.stderr.write(something + '\n')
    else:
        sys.stdout.write(something + '\n')
    sys.exit( status )


def normalize_paths():
    """ just make sure we remove added / or // etc"""
    for e in ['-src','-obj','-htm','-dst','-res']:
        config[e] = os.path.normpath(config[e])
    # library paths are contained in a list..
    for i in xrange(len(config['-lib'])):
        config['-lib'][i] = os.path.normpath(config['-lib'][i])


def expand_variables():
    """ expand shell variables + HOME shortcut tilde [~] """
    for k in config:
        if config[k] and isinstance(config[k], basestring):
            config[k] = os.path.expanduser(config[k])
            config[k] = os.path.expandvars(config[k])


def dep_info_exit( pkgs ):
    """ print dependency info gathered (with regexp!) """
    for k in pkgs:
        pkgs[k].info()
    sys.exit(0)


def list_settings_exit():
    """ print default||config arguments """

    print("\n Options and their content:\n")
    for k in config:
        if k.startswith("-"):
            print("%12s => %s"%(k, config[k]))
    print("")
    sys.exit(0)


def help_flags_exit():
    """ print usage + flags and exit """

    global plugins

    print( __doc__ )

    plugin_flags = []

    for k in plugins:
        if 'help_flags' in dir(plugins[k]):
            plugin_flags.append( plugins[k].help_flags() )

    if plugin_flags:
        print(" plugin options:\n")
        print('\n'.join(plugin_flags)+ '\n')

    print("  NOTE: valid 'javac/javadoc' options can be given\n")

    sys.exit(0)



# lambda filters for the path-walker
def any_matcher(f): return True
def jar_matcher(f): return f.endswith('.jar')
def java_matcher(f): return f.endswith('.java')
def class_matcher(f): return f.endswith('.class')
def java_but_no_test(f): return java_matcher(f) and not f.endswith('Test.java')
def py_module_matcher(f): return f == '__init__.py'


# ______________________________________________________________ main


def main():
    """ everything is done from here, let's not be cryptic! """

    # start timer, report time used if work_done
    t0        = time.time()
    work_done = False
    matcher   = java_but_no_test

    # init command line parser
    init_parser()
    # look for plugins and initialize
    plugin_init()
    # parse config files; $HOME/.jzrc etc..
    parse_config()
    # parse command line arguments
    parse_args( sys.argv[1:] )
    # remove traling '/' and so on.
    normalize_paths()
    # expand shell variables $HOME/$PWD... %USERDIR% etc. on Windows
    expand_variables()
    # notify plugins that parsing is done with
    plugin_after_parsing()
    # do simple options [-version,-help,-clean,-list]
    if config['-list']   : list_settings_exit()
    if config['-help']   : help_flags_exit()
    if config['-clean']  : clean()
    if config['-version'] and not config['-doc']:
        echo_exit( __version__ )
    # classpath + create objects for lib/*.jar
    libs = build_classpath()
    # update plugins with libs and classpath info
    plugin_deps(libs)
    # we need to do some extra work if we are testing
    if config['-test']:
        matcher = java_matcher # includes *Test.java also
        write_junit_stub()     # include code stub to run tests
        junit_sanity()         # make sure JUnit is in classpath
    # give the matcher function to the plugins
    matcher = plugin_get_matcher( matcher )
    # check sanity, i.e. jdk installed (javac/javadoc)
    if config['-doc']:
        jdk_sanity('javadoc.exe' if config['windows'] else 'javadoc')
    else:
        jdk_sanity('javac.exe' if config['windows'] else 'javac')
    # fetch java files
    files = path_walk(config['-src'], matcher, config['-strip']);
    if not files:
        if os.path.isdir(config['-src']):
            echo_exit("No java files found in: %s"% config['-src'], 1)
        else:
            echo_exit("Directory not found: %s"% config['-src'], 1)
    # allow plugins to manipulate the files we have fetched
    files = plugin_get_files( files )
    # create javadoc (+exit) if -doc option was given
    if config['-doc'] : javadoc(files)
    # create Pkg objects from java packages
    pkgs = find_pkgs( files )
    # allow plugins to manipulate packages
    plugin_set_pkgs( pkgs )
    # debug option, prints dependency info
    if config['-dep']: dep_info_exit( pkgs )
    # create links from parents to children
    if not config['-fast']:
        build_dep_graph( pkgs )
    # calculate which packages need to be compiled
    find_outdated_pkgs( pkgs )
    # notify plugins that dependency graph is built
    plugin_build_calculated( pkgs )
    # compile outdated packages
    work_done = javac_outdated_pkgs( pkgs )
    # zip classes into jar file
    zip_objs( pkgs, libs, work_done )
    # add files in config['-res'] to jar file
    add_resources()
    # run junit tests if -test option was given
    if config['-test']: junit()
    # add other dependencies to jar
    if config['-output'] or config['-pack']:
        add_deps(libs)
    # produce executable shell/batch script
    if config['-output']:
        update = assert_main( pkgs )
        bash_script(update or work_done)
    # only display time if we actually did some work
    if work_done:
        info("time used: %.3f seconds\n", ( time.time() - t0 ))


# ______________________________________________________________ Pkg

class Pkg(object):
    """
    Represents a package, i.e. list of files
    that belong to the same package.
    """
    def __init__(self, name):
        self.name  = name
        self.files = []
        self.entry = []
        self.deps  = set()
        self.child = set()
        self.make  = False

    def add_file(self, f):
        self.files.append( f )

    def add_entry(self, e):
        """ add entry point, class with main """
        base = os.path.basename(e)
        if self.name != '.':
            entry_point = "%s.%s"%(self.name, base[:-5])
        else:
            entry_point = base[:-5]
        self.entry.append(entry_point)

    def depends_on(self, d):
        """ self.Pkg depends on 'd' """
        self.deps.add(d)

    def add_child(self, c):
        """ a package 'c' depends on us """
        self.child.add(c)

    def modified(self, obj_root):
        """ only return modified files; for -fast option """

        modified_files = []

        # where we can expect to find compiled output
        if self.name == '.': # special case no package name
            root = obj_root
        else:
            root = os.path.join(obj_root, self.name.replace('.', os.sep))

        for f in self.files:
            f_class = os.path.basename(f)[:-5] + '.class'
            f_path  = os.path.join(root, f_class)
            if os.path.isfile( f_path ):
                java_mod  = os.stat(f).st_mtime
                class_mod = os.stat(f_path).st_mtime
                if java_mod > class_mod:
                    modified_files.append( f )
            else:
                modified_files.append( f )

        return modified_files

    def stat_compare(self, obj_root):
        """
        stat .class files and .java files to
        compare the modified timestamp. i.e.
        compile if .java is newer than .class
        """

        # where we can expect to find compiled output
        if self.name == '.': # special case no package name
            root = obj_root
        else:
            root = os.path.join(obj_root, self.name.replace('.', os.sep))

        for f in self.files:
            f_class = os.path.basename(f)[:-5] + '.class'
            f_path  = os.path.join(root, f_class)
            if os.path.isfile( f_path ):
                java_mod  = os.stat(f).st_mtime
                class_mod = os.stat(f_path).st_mtime
                if java_mod > class_mod:
                    self.needs_make()
                    break
            else:
                self.needs_make()
                break

    def latest_class_file(self, obj_root):
        """ report timestamp of newest .class file of package"""

        # a bit of duplicate code here, hmm

        newest = 0
        root   = os.path.join(obj_root, self.name.replace('.', os.sep))

        for f in self.files:
            f_class = os.path.basename(f)[:-5] + '.class'
            f_path  = os.path.join(root, f_class)
            if os.path.isfile( f_path ):
                class_mod = os.stat(f_path).st_mtime
                if class_mod > newest:
                    newest = class_mod
        return newest

    def needs_make(self):
        """
        this package and its children needs to be compiled
        """
        # already handled
        if not self.make:
            self.make = True
            for c in self.child:
                c.make = True # not recursive

    def __hash__(self):
        """ to make the set do what it should """
        return hash(self.name)

    def __eq__(self, other):
        """ to make the set do what it should """
        return self.name == other.name

    def info(self):
        """ print some info about myself """
        print('\npkg\n   %s'% self.name)
        print('fls')
        for f in self.files:
            print('   %s'% f)
        print('dep')
        for d in self.deps:
            print('   %s'% d)
        if self.entry:
            print('haz')
            for e in self.entry:
                print('   %s'% e)
        print('')

# ______________________________________________________________ Lib

class Lib(object):
    """ Represents a .jar file we include """
    def __init__(self, fname):
        self.fname = fname
        
    def __repr__(self):
        return self.fname

    def base(self):
        """ just an alias: os.path.basename(my.file.name) """
        return os.path.basename(self.fname)

    def add_to_old(self, jar_fh):
        """ add my files to jar_fh we are not junit """
        base = os.path.basename( self.fname )
        m = junit_regex.match( base )
        if m: return  # skip junit
        zip_fh = zipfile.ZipFile(self.fname, 'r')
        info("add 2 zip: %s\n",self.fname)
        names  = zip_fh.namelist()
        for n in names:
            # add class files + any other file which is not
            # a MANIFEST.MF file, some libs have important
            # files stuffed into them (mysql.jar for instance)
            if not os.path.basename(n) == 'MANIFEST.MF':
                b = zip_fh.read(n)
                jar_fh.writestr(n, b)
        zip_fh.close()

    def add_to(self, jar_fh):
        """ add this library to the zip|jar file """
        info("add 2 zip: %s\n", self.base())
        jar_fh.write(self.fname, os.path.join('lib', self.base()))


# ______________________________________________________________ utility

def path_walk(dir_name, criteria, exclude):
    """
    traverse 'dir_name', collected files matching 'criteria'
    and ignore directories with names in comma-separated
    list found in exclude
    """

    ignore_dirs = None
    collected   = []

    if exclude: # We ignore .svn/.bzr/.hg/.git by default
        ignore_dirs = exclude.split(',')

    for root, dirs, files in os.walk(dir_name):
        # do not look in repository dires (.git,.svn ..)
        if dirs and ignore_dirs:
            for ign in ignore_dirs:
                if ign in dirs: dirs.remove(ign)
        if files:
            for f in files:
                if criteria(f):
                    collected.append(os.path.join(root, f))

    return collected


#TODO pretty print command
def run_cmd(cmd, dryrun=False, errmsg=''):
    """ run a command in subprocess || print command """
    if dryrun:
        pretty_print( cmd )
    else:
        fail = subprocess.call(cmd)
        if fail:
            if not errmsg:
                die("cmd failed: %s\n", ' '.join(cmd))
            else:
                die("%s\n", errmsg)


def pretty_print(cmd, maxwidth=79):
    """ print a command but break it up if it's too wide """

    cur = 0

    for i, e in enumerate( cmd ):
        if cur + len(e) >= maxwidth:
            sys.stdout.write("\\\n   %s"%e)
            cur = len(e) + 3
        else:
            sys.stdout.write(" %s"%e)
            cur += len(e) + 1

    sys.stdout.write("\n")

#FIXME report meaningful feedback when you lack rights
def rm_rf(d):
    """ rm -rf modified from activestate: 552732"""
    if not os.path.isdir(d): return
    for p in (os.path.join(d,f) for f in os.listdir(d)):
        if os.path.isdir(p):
            rm_rf(p)
        elif os.path.isfile(p):
            os.unlink(p)
    os.rmdir(d)


def rm_empty_dirs(d, silent=False):
    """ remove empty dirs recursively """
    if not os.path.isdir(d): return
    while d and not os.listdir(d):
        tmp = os.path.dirname(d)
        if not silent:
            info('rmdir : %s\n' % d)
        os.rmdir(d)
        d = tmp


def dir_or_mkdir(pathname):
    if not os.path.isdir(pathname):
        os.makedirs(pathname)


def die(fmt, *args):
    """ print something to stderr and exit(1) """
    out_str = fmt%(args) if args else "%s"%(fmt)
    sys.stderr.write(out_str)
    sys.exit(1)


def which(executable):
    """ checks whether the executable can be found in PATH variable"""
    # executable already contains a path.
    if os.path.dirname(executable) != '':
        if os.access (executable, os.X_OK):
            return executable

    if not os.environ.has_key('PATH') or os.environ['PATH'] == '':
        p = os.defpath
    else:
        p = os.environ['PATH']

    pathlist = p.split(os.pathsep)

    for path in pathlist:
        f = os.path.join(path, executable)
        if os.access(f, os.X_OK):
            return f
    return None


def follow_link(fname):
    """ same as '/bin/readlink -f fname' """
    while os.path.islink(fname):
        fname = os.readlink(fname)
    return fname


def config_to_argv(fname):
    """
    If fname is a file strip comments + split on whitespace.
    This function will be praised by Donald Knuth because of
    its low complexity etc.
    """
    if os.path.isfile(fname):
        cmt_strip = re.compile(r'#.*$')
        actual_lines = []
        fd = open(fname, 'r')
        for line in fd.readlines():
            clean_line = cmt_strip.sub('',line).strip()
            if clean_line:
                actual_lines.append( clean_line )
        fd.close()
        if actual_lines:
            return ' '.join(actual_lines).split()
    return None


def wget(link, HEADERS={}):
    """ fetch a resource over HTTP """
    import urllib2 # adds 10-20ms, hide it here ☻
    r = urllib2.Request( link, None, HEADERS )
    return urllib2.urlopen(r).read()


# ______________________________________________________________ Pyopt

# getopt   - cannot parse arguments mixed with options
#            (i was wrong; gnu_getopt does that, oh well...)
# optparse - very complex and shitty library IMO

class Option(object):
    """ base class for BoolOption and StrOption"""
    def __init__(self, flags):
        self.flags = flags

    def __hash__(self):
        return ''.join(self.flags).__hash__()

class BoolOption(Option):
    """ boolean flag, defaults to false """
    def __init__(self, flags):
        super(BoolOption, self).__init__(flags)
        self.found = False

    def is_set(self):
        return self.found

    def reset(self):
        self.found = False

    def __str__(self):
        return "%50s => %s"%(' '.join(self.flags), self.found)


class StrOption(Option):
    """ str options represents all non-bool flags """
    def __init__(self, flags):
        super(StrOption, self).__init__(flags)
        self.args = []

    def is_set(self):
        return len(self.args) > 0

    def reset(self):
        self.args = []
    
    def add(self, arg):
        self.args.append(arg)
    
    def get(self):
        return self.args[0]

    def get_all(self):
        return self.args

    def __str__(self):
        return "%50s => %s"%(' '.join(self.flags), ''.join(self.args))


class Pyopt(object):
    """ simple command line parser """
    def __init__(self):
        self.options = {}

    def add_bool(self, flag_str):
        """ option/flag that requires no argument(s)"""
        flags = flag_str.split()
        b = BoolOption(flags)
        self.add_flag(flags, b)

    def add_str(self, flag_str):
        """ option/flag that take(s) argument(s)"""
        flags = flag_str.split()
        s = StrOption(flags)
        self.add_flag(flags, s)

    def add_str_fancy(self, flag_str):
        """ same as add_str but make flag fancy first"""
        fancy = self.make_fancy(flag_str)
        s = StrOption(fancy)
        self.add_flag(fancy, s);

    def add_flag(self, flags, option):
        """ flags meaning the same point to same option"""
        used = self.in_use(flags)
        if used:
            sys.stderr.write("[WARNING] '%s' flag already in use\n"%(used))
        else:
            for f in flags:
                self.options[f] = option

    def in_use(self, flags):
        """ assert that we do not have option conflicts"""
        for f in flags:
            if f in self.options:
                return f
        return None

    def make_fancy(self, flag_str):
        """
        '-f --flag' => [-f,-f=,-flag,-flag=,--flag,--flag=]
        """
        flags = flag_str.split()
        fancy_flags = []
        for f in flags:
            if f.startswith("--"):
                fancy_flags.append(f[1:])
                fancy_flags.append(f[1:] + "=")
                fancy_flags.append(f)
                fancy_flags.append(f + "=")
            elif f.startswith("-"):
                fancy_flags.append(f)
                fancy_flags.append(f + "=")
            else:
                fancy_flags.append(f)
        return fancy_flags

    def reset(self):
        """
        reset all options to blank/false
        """
        hash_set = set(self.options.values())
        for o in hash_set:
            o.reset()

    def is_set(self, flag):
        return self.options[flag].is_set()
    
    def get(self, flag):
        return self.options[flag].get()

    def get_all(self, flag):
        return self.options[flag].get_all()

    def is_option(self, opt):
        return opt in self.options.keys()

    def parse(self, argv):
        rest = []
        while argv:
            a = argv[0]
            argv = argv[1:]
            if self.is_option(a):
                if type(self.options[a]) == BoolOption:
                    self.options[a].found = True
                else:
                    if not argv:
                        die("missing argument for: %s\n", a)
                    else:
                        x = argv[0]
                        argv = argv[1:]
                        self.options[a].add(x)
            else:
                if (not self.juxta_bool(a)) and (not self.juxta_str(a)):
                    rest.append(a)
        return rest

    def juxta_bool(self, arg):
        """ 
        juxta_bool('-abcd') == True

        if '-a','-b','-c' and '-d' are bool options
        """
        if len(arg) > 2:
            single = list(arg[1:])
            for a in single:
                if not self.is_option("-"+a):
                    return False
                if not type(self.options["-"+a]) == BoolOption:
                    return False
            # set them all
            for a in single:
                self.options["-"+a].found = True
            return True
        else:
            return False

    def juxta_str(self, arg):
        """
        juxta_str('-flagARG') == True

        if '-flag' is a string option
        """
        max = 0
        tmp = ""
        for k in self.options.keys():
            if arg.startswith(k):
                if type(self.options[k]) == StrOption:
                    if len(k) > max:
                        max = len(k)
                        tmp = k
        if max > 0:
            self.options[tmp].add(arg[len(tmp):])
            return True
        return False

    def __str__(self):
        return '\n'.join(map(lambda x: x.__str__(), set(self.options.values())))

# ______________________________________________________________ init

if __name__ == '__main__':
    try:
        #cProfile.run("main()")
        main()
    except Exception, inst:
        traceback.print_exc()
        sys.stderr.write("%s\n"% inst)
        
